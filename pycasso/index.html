<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Pycasso</title>
  </head>
  <body>
    <canvas width="150" height="150" style="border: 2px solid red"></canvas>

    <div>
      <button onclick="BUFFER.rewindReadIndex(40)">rewind</button>
      <button onclick="BUFFER.advanceReadIndex(40)">forward</button>
    </div>
    <script>
      var ws = new WebSocket("ws://localhost:3001");
      ws.onopen = function () {
        console.log("Connected to server");
      };
      ws.onmessage = function (event) {
        // Immediately draw the latest message for messages that edit the page
        if (event.data.startsWith("resize")) {
          parseAndDraw(event.data);
          return;
        }
        // Store normal drawing messages in the buffer
        BUFFER.push(event.data);
      };
      ws.onclose = function () {
        console.log("Disconnected from server");
      };
    </script>

    <script>
      class CircularBufferArray {
        constructor(maxSize) {
          this.maxSize = maxSize;
          this.buffer = new Array(maxSize).fill(null);
          this.head = 0;
          this.tail = 0;
          this.readIndex = null; // Updated to be null initially
          this.isFull = false;
          this.untouched = true;
        }

        push(item) {
          // If readIndex is null or points to the current tail (which will be overwritten),
          // set it to head (the next oldest data after push) to ensure we start reading from the oldest data.

          if (this.readIndex === null) {
            this.readIndex = this.head;
          } else if (this.readIndex === this.tail) {
            this.readIndex = (this.readIndex + 1) % this.maxSize;
          }

          if (!this.untouched && this.tail === this.head) {
            this.isFull = true;
            this.head = (this.head + 1) % this.maxSize; // Move head forward when buffer is full
          }

          this.untouched = false;
          this.buffer[this.tail] = item;
          this.tail = (this.tail + 1) % this.maxSize;
        }

        read() {
          console.log(
            "this.untouched",
            this.untouched,
            "this.readIndex",
            this.readIndex,
            this.buffer[this.readIndex]
          );
          if (this.untouched) return null;

          if (this.readIndex === null) {
            this.readIndex = this.head;
          }

          const item = this.buffer[this.readIndex];

          // No automatic advance of readIndex here; use advanceReadIndex for manual control
          return item;
        }

        advanceReadIndex(steps = 1) {
          if (this.readIndex === null) this.readIndex = this.head; // Start reading from the oldest data if not started yet.

          // steps = steps % this.maxSize; // Ensure steps is within buffer size.

          // Calculate the total available items from readIndex to tail.
          const tail =
            this.readIndex >= this.tail ? this.tail + this.maxSize : this.tail;

          const totalAvailable = tail - this.readIndex - 1;
          steps = Math.min(steps, totalAvailable);

          this.readIndex = (this.readIndex + steps) % this.maxSize;
        }

        rewindReadIndex(steps = 1) {
          if (this.readIndex === null)
            this.readIndex = (this.tail - 1 + this.maxSize) % this.maxSize; // Start from the newest if reading hasn't started.

          // Calculate the total available items from readIndex to tail.
          const head =
            this.readIndex < this.head ? this.head - this.maxSize : this.head;

          const totalAvailable = this.readIndex - head;
          steps = Math.min(steps, totalAvailable);

          this.readIndex =
            (this.readIndex - steps + this.maxSize) % this.maxSize;
        }

        isEmpty() {
          return !this.isFull && this.head === this.tail;
        }
      }
    </script>

    <script>
      const canvas = document.querySelector("canvas");
      const ctx = canvas.getContext("2d");

      const BUFFER = new CircularBufferArray(1000);

      let LATEST_MESSAGE_ID = -1;
      animate();

      function animate() {
        // if (LATEST_MESSAGE_ID !== BUFFER.readIndex) {
        const m = BUFFER.read();
        console.log("Drawing message: ", m);
        if (m) {
          LATEST_MESSAGE_ID = BUFFER.readIndex;
          parseAndDraw(m);
          BUFFER.advanceReadIndex(1);
        }
        // }

        requestAnimationFrame(animate);
      }

      function parseMessage(message) {
        return message.split("\n").map((command) => {
          // Find the index of the first occurrence of ":"
          var separatorIndex = command.indexOf(":");
          if (separatorIndex === -1) {
            console.log("Invalid command format", command);
            return; // Skip this command if the format is invalid
          }

          // Extract the function name and arguments based on the index
          var functionName = command.substring(0, separatorIndex);
          var args = command.substring(separatorIndex + 1).split(";");

          return { functionName, args };
        });
      }

      function parseAndDraw(msg) {
        console.log("Drawing message: ", msg);
        if (!msg) return;

        var commands = parseMessage(msg);

        commands.forEach(function ({ functionName, args }) {
          executeCanvasCommand(functionName, args);
        });
      }

      function executeCanvasCommand(functionName, args) {
        switch (functionName) {
          case "resize":
            canvas.setAttribute("width", args[0]);
            canvas.setAttribute("height", args[1]);

            canvas.style.width = args[0];
            canvas.style.height = args[1];
            break;
          case "clear":
            ctx.clearRect(...args.map(Number));
            break;
          case "fillStyle":
            ctx.fillStyle = args.join("");
            break;
          case "fillRect":
            ctx.fillRect(...args.map(Number));
            break;
          default:
            console.log("Unknown command: " + functionName);
        }
      }
    </script>
  </body>
</html>
